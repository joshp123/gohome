# RFC: Proto-Driven Nix-Native Config (Textproto, Single File)

- Date: 2026-01-01
- Status: Draft
- Audience: operators, infra engineers, plugin authors, core maintainers
- Owner: GoHome core

## 0) Project context (for new agents)

GoHome is a Nix-native home automation system written in Go. It replaces Home
Assistant with a deterministic, compile-time plugin architecture:

- NixOS is the source of truth for configuration.
- Plugins are compiled into the binary (no runtime loading).
- Secrets are managed via agenix/sops and referenced as file paths.
- There is no UI; Grafana is the only dashboard surface.
- “If it compiles, it works” is the core philosophy.

This RFC defines how runtime configuration is represented, validated, and loaded
for the GoHome server and its plugins.

## 1) Narrative: what we are building and why

Today config is passed to GoHome via environment variables. That is untyped,
leaky, and brittle. We want a **single, human-readable config file** generated
by Nix from typed module options and parsed into **protobuf-generated Go types**
at startup. This gives us:

- Nix eval-time validation (types, defaults, assertions)
- A canonical config artifact on disk (easy to inspect)
- Typed Go structs (from proto) with fail-fast startup validation
- A path that scales to hundreds or thousands of plugins

The goal is a **Nix-native, typed, single-file config** with no env var surface.

## 1.1) Non-negotiables

- Nix is the source of truth for runtime config values.
- Exactly one canonical config file on disk.
- No env-var config surface for the server runtime.
- No JSON/TOML/YAML (config file is textproto).
- Secrets are file paths only (agenix/sops), never inline values.
- Startup must fail fast on invalid/missing config.
- Prefer minimal config with sensible defaults.

## 2) Goals / Non-goals

Goals:
- Protobuf as the schema source of truth.
- NixOS module options generated from proto (types, defaults, descriptions).
- One canonical, human-readable config file on disk.
- Go loads the file into generated types and validates invariants.
- Plugin config remains typed and namespaced.
- Plugin presence implies enablement (no separate enable flags).

Non-goals:
- Runtime config editing or live reload.
- Multi-instance config overlays or dynamic sourcing.
- Supporting non-NixOS config generation in MVP.
- Replacing plugin-owned OAuth state (mutable) with Nix.

## 3) System overview

1) `config.proto` defines the canonical schema (single source of truth).
2) `protoc` generates Go types and a descriptor set.
3) `protoc-gen-nix` generates NixOS module options from the descriptor.
4) Nix evaluates user config and writes **one textproto file**.
5) Go loads the textproto at startup into generated types and validates.

## 4) Components and responsibilities

- `proto/config/v1/config.proto`
  - Canonical config schema.
  - Comments and custom options drive Nix option descriptions and defaults.
- `protoc-gen-nix` (custom)
  - Input: proto descriptor set.
  - Output: NixOS module options for `services.gohome.*`.
- `nix/module.nix`
  - Imports generated options.
  - Materializes `/etc/gohome/config.pbtxt`.
- `internal/config`
  - Go config types (generated by `protoc`).
  - `Load(path)` + `Validate()` for invariants.
- `cmd/gohome/main.go`
  - Reads config file path (fixed default).
  - Fails fast on load/validate errors.
- Plugins
  - Define plugin config messages.
  - Consume typed config input.

## 5) Inputs / workflow profiles

Minimum inputs (Nix options):
Core: none unless overriding defaults.
OAuth: required blob settings (paths to secrets).
Plugins: presence of a plugin config block enables it.

Validation rules:
- Nix enforces types and required secrets at eval time.
- Go enforces structural invariants at startup.

## 6) Artifacts / outputs

- `config.pb.go` (generated Go types)
- `config.nix` (generated NixOS module options)
- `/etc/gohome/config.pbtxt` (canonical, human-readable config)

## 7) State machine (if applicable)

Not applicable. Config is immutable; OAuth state remains mutable and separate.

## 8) API surface (protobuf)

No gRPC API changes. This RFC introduces a new config schema proto.

## 9) Interaction model

Operators edit **one** Nix file (`nix/hosts/<host>.nix`) and run
`nixos-rebuild switch`. GoHome reads the generated config file at startup.

## 10) System interaction diagram

```
config.proto
   | protoc + plugins
   v
config.pb.go + config.nix
   | nixos-rebuild
   v
/etc/gohome/config.pbtxt
   | gohome startup
   v
Go structs + Validate() -> running service
```

## 11) API call flow (detailed)

Not applicable.

## 12) Determinism and validation

- Nix enforces types + required values at eval time.
- Go enforces schema and invariants at startup (textproto parsing + Validate()).
- No best-effort fallback; failures are explicit.

## 13) Outputs and materialization

### 13.1) Canonical config file (textproto example)

```
schema_version: 1
core {
  grpc_addr: "0.0.0.0:9000"
  http_addr: "0.0.0.0:8080"
  dashboard_dir: "/var/lib/gohome/dashboards"
}
oauth {
  blob_endpoint: "https://s3.eu-central-1.amazonaws.com"
  blob_bucket: "gohome-oauth-homelab-eu-central-1"
  blob_prefix: "gohome/oauth"
  blob_access_key_file: "/run/agenix/gohome-oauth-blob-access-key"
  blob_secret_key_file: "/run/agenix/gohome-oauth-blob-secret-key"
  blob_region: "eu-central-1"
}
tado {
  bootstrap_file: "/run/agenix/tado-token"
}
daikin {
  bootstrap_file: "/run/agenix/daikin-token"
}
```

Rules:
- `schema_version` is required and must be `1`.
- Secrets are always `*_file` paths.
- Plugin sections are inline (no per-plugin config files).
- Plugin sections imply enablement (no separate enable flag).

## 14) Proto schema conventions

- Package: `gohome.config.v1` (or `gohome.config.core.v1` if split).
- Field numbers are stable and never reused.
- Removed fields are `reserved` (number + name).
- Use `optional` for fields that map to `null`/`mkOption` defaults.
- Comments are treated as option descriptions in Nix.

### 14.1) Nix-specific metadata in proto

`protoc-gen-nix` needs type/default hints that proto alone cannot express.
Define custom field options under `gohome.nix`:

- `(gohome.nix.type)` for Nix type hints (e.g., `path`, `port`, `nullOr path`).
- `(gohome.nix.default)` for defaults when proto zero values are ambiguous.
- `(gohome.nix.secret)` boolean to mark file-path secrets for extra assertions.

These options are consumed only by the generator; they do not affect runtime.

## 15) Plugin config composition (single file, scalable)

We need both **plugin-owned schemas** and **one canonical config file**.
Recommended approach:

- Each plugin owns a `Config` message in its package.
- A build step generates a single `config.proto` that imports the enabled plugin
  configs and exposes them as inline fields on `gohome.config.v1.Config`.
- The user still writes one Nix file; the on-disk output is one textproto file.

This keeps the operator experience simple and scales to large plugin counts
without hand-editing a mega proto.

## 15.1) Defaults and auto-discovery

Defaults (unless overridden):
- `core.grpc_addr = "0.0.0.0:9000"`
- `core.http_addr = "0.0.0.0:8080"`
- `core.dashboard_dir = "/var/lib/gohome/dashboards"`
- `oauth.blob_prefix = "gohome/oauth"`
- `oauth.blob_region = ""` (unset)

Tado `home_id`:
- Default: **auto-discover** via `/me`.
- If exactly one home is returned, use it.
- If multiple homes exist, fail fast and require `home_id` override.

## 16) Build integration

- `protoc` generates Go types + descriptor set.
- `protoc-gen-nix` generates `config.nix` from the descriptor set.
- `nix/module.nix` imports `config.nix` and renders `/etc/gohome/config.pbtxt`.
- Go loads the config with `prototext.Unmarshal` into generated types.

## 17) Secrets handling

- Secrets live in agenix/sops and are referenced as file paths.
- Nix asserts that secret file options are provided when required.
- Go reads secret file paths only when needed (runtime state, OAuth, etc.).

## 18) Migration path

1) Add proto schema + generator stubs.
2) Generate Nix options from proto (keep existing env usage).
3) Emit `/etc/gohome/config.pbtxt` and wire `cmd/gohome` to parse it.
4) Migrate plugin config reads away from env vars.
5) Remove env file and env reads entirely.

## 19) Open questions

- Plugin config aggregation: field-number policy and generation strategy.
- Do we adopt `buf` for linting/breaking-change detection?
- Should `gohome schema export` return proto, descriptor, or both?

## 20) Brutal self-review (required)

- Junior engineer: Is the textproto example enough to understand the file shape?
- Mid-level engineer: Is the generator responsibility clear and testable?
- Senior/principal engineer: Does the aggregation step scale to 1000 plugins?
- PM: Does this reduce operational mistakes and support burden?
- EM: Is the migration staged to avoid production breakage?
- External stakeholder: Any secrets exposure? No, only file paths.
- End user: Will config changes be predictable? Yes, rebuild-only, fail-fast.
